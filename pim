#!/usr/bin/env python3

# Copyright (c) 2010 James Campos

### TODO ###
# resolve scrollbar issue
# hide pointer in fullscreen
# status text
# better shift masking
# rotating
# pim.desktop
# mouse panning / keybinds
# fit width / height
# marking (echo $current >> pim-marked)
# set as wallpaper
# animated gifs

### Thanks ###
# alterecco, for making [visible](http://drop.dotright.net/visible) (dead),
#   and inspiring me to make this program.


### Pim ###
# A Python image viewer with vim-like keybindings.
# v0.2.0

from optparse import OptionParser
from random import shuffle
import mimetypes
from gi.repository import GLib
from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import GdkPixbuf
import os
import shutil


class Pim:
    def __init__(self):
        self.fullscreen = False
        self.slideshow = False
        self.slideshow_delay = 5
        self.random = False
        self.remember_position = False
        self.zoom_lock = False

        self.binds = (
            #(modifer, key, function, args)
            #supported modifiers: Gdk.ModifierType.SHIFT_MASK, Gdk.ModifierType.CONTROL_MASK, Gdk.ModifierType.MOD1_MASK (alt key)
            (0,              Gdk.KEY_q,     self.quit),
            (0,              Gdk.KEY_f,     self.toggle_fullscreen),

            #if True, scroll in the horizontal direction.
            (0,              Gdk.KEY_h,     self.scroll, Gtk.ScrollType.STEP_BACKWARD, True),
            (0,              Gdk.KEY_j,     self.scroll, Gtk.ScrollType.STEP_FORWARD, False),
            (0,              Gdk.KEY_k,     self.scroll, Gtk.ScrollType.STEP_BACKWARD, False),
            (0,              Gdk.KEY_l,     self.scroll, Gtk.ScrollType.STEP_FORWARD, True),

            (Gdk.ModifierType.SHIFT_MASK, Gdk.KEY_H,     self.scroll, Gtk.ScrollType.PAGE_BACKWARD, True),
            (Gdk.ModifierType.SHIFT_MASK, Gdk.KEY_J,     self.scroll, Gtk.ScrollType.PAGE_FORWARD, False),
            (Gdk.ModifierType.SHIFT_MASK, Gdk.KEY_K,     self.scroll, Gtk.ScrollType.PAGE_BACKWARD, False),
            (Gdk.ModifierType.SHIFT_MASK, Gdk.KEY_L,     self.scroll, Gtk.ScrollType.PAGE_FORWARD, True),

            (0,              Gdk.KEY_Left,  self.scroll, Gtk.ScrollType.STEP_BACKWARD, True),
            (0,              Gdk.KEY_Down,  self.scroll, Gtk.ScrollType.STEP_FORWARD, False),
            (0,              Gdk.KEY_Up,    self.scroll, Gtk.ScrollType.STEP_BACKWARD, False),
            (0,              Gdk.KEY_Right, self.scroll, Gtk.ScrollType.STEP_FORWARD, True),

            (0,              Gdk.KEY_w,     self.scroll, Gtk.ScrollType.STEP_BACKWARD, False),
            (0,              Gdk.KEY_a,     self.scroll, Gtk.ScrollType.STEP_BACKWARD, True),
            (0,              Gdk.KEY_s,     self.scroll, Gtk.ScrollType.STEP_FORWARD, False),
            (0,              Gdk.KEY_d,     self.scroll, Gtk.ScrollType.STEP_FORWARD, True),

            (Gdk.ModifierType.SHIFT_MASK, Gdk.KEY_W,     self.scroll, Gtk.ScrollType.PAGE_BACKWARD, False),
            (Gdk.ModifierType.SHIFT_MASK, Gdk.KEY_A,     self.scroll, Gtk.ScrollType.PAGE_BACKWARD, True),
            (Gdk.ModifierType.SHIFT_MASK, Gdk.KEY_S,     self.scroll, Gtk.ScrollType.PAGE_FORWARD, False),
            (Gdk.ModifierType.SHIFT_MASK, Gdk.KEY_D,     self.scroll, Gtk.ScrollType.PAGE_FORWARD, True),

            (0,              Gdk.KEY_g,     self.scroll, Gtk.ScrollType.START, False),
            (Gdk.ModifierType.SHIFT_MASK, Gdk.KEY_G,     self.scroll, Gtk.ScrollType.END, False),

            (Gdk.ModifierType.SHIFT_MASK, Gdk.KEY_T,     self.zoom_delta, -.5),
            (0,              Gdk.KEY_t,     self.zoom_delta, +.5),
            (0,              Gdk.KEY_b,     self.move_index, -1),
            (0,              Gdk.KEY_e,     self.toggle_slideshow),
            (Gdk.ModifierType.SHIFT_MASK, Gdk.KEY_X,     self.delete, -1),
            (0,              Gdk.KEY_x,     self.delete, 0),
            (0,              Gdk.KEY_z,     self.toggle_zoom_lock),

            (0,              Gdk.KEY_1,    self.zoom_to, 1),
            (0,              Gdk.KEY_2,    self.zoom_to, 2),
            (0,              Gdk.KEY_3,    self.zoom_to, 3),
            #back to fullscreen
            (0,              Gdk.KEY_5,    self.zoom_to, 0),

            (0,              Gdk.KEY_space, self.move_index, 1),
            (Gdk.ModifierType.SHIFT_MASK, Gdk.KEY_space, self.move_index, -1),
            )


    def toggle_zoom_lock(self):
        self.zoom_lock = not self.zoom_lock


    def delete(self, delta):
        current = self.paths[self.index]
        self.paths.remove(current)
        if not os.path.isdir('/tmp/pim-trash'):
            os.mkdir('/tmp/pim-trash')
        shutil.move(current, '/tmp/pim-trash')
        if len(self.paths) == 0:
            self.quit()
        else:
            self.move_index(delta)


    def quit(self):
        if self.remember_position and len(self.paths):
            try:
                f = open('pim-position', 'w')
                f.writelines(self.paths[self.index])
                f.close()
            except IOError as e:
                print(e)
        Gtk.main_quit()


    def scroll(self, scrolltype, horizontal):
        self.scrolled_win.emit('scroll-child', scrolltype, horizontal)


    def toggle_slideshow(self):
        self.slideshow = not self.slideshow
        if self.slideshow:
            self.timer_id = GLib.timeout_add_seconds(self.slideshow_delay, self.move_index, 1)
        else:
            GLib.source_remove(self.timer_id)
        self.update_title()


    def toggle_fullscreen(self):
        self.fullscreen = not self.fullscreen
        if self.fullscreen:
            self.win.fullscreen()
            self.zoom_percent = self.get_fullscreen_zoom_percent()
        else:
            self.win.unfullscreen()
            self.zoom_percent = 1
        self.update_image()


    def get_fullscreen_zoom_percent(self):
        pboWidth = self.pixbufOriginal.get_width()
        pboHeight = self.pixbufOriginal.get_height()
        pbRatio = pboWidth / pboHeight

        if pbRatio > self.sRatio:
            #pixbuf is proportionally wider than screen
            return self.sWidth / pboWidth
        else:
            return self.sHeight / pboHeight


    def update_image(self):
        ''' Show the final image '''

        pboWidth = self.pixbufOriginal.get_width()
        pboHeight = self.pixbufOriginal.get_height()
        if self.zoom_percent is 1:
            pixbufFinal = self.pixbufOriginal
            pbfWidth = pboWidth
            pbfHeight = pboHeight
        else:
            pbfWidth = int(pboWidth * self.zoom_percent)
            pbfHeight = int(pboHeight * self.zoom_percent)
            pixbufFinal = self.pixbufOriginal.scale_simple(
                    pbfWidth, pbfHeight, GdkPixbuf.InterpType.BILINEAR)
        self.image.set_from_pixbuf(pixbufFinal)

        self.update_title()
        if not self.fullscreen:
            self.resize_window(pbfWidth, pbfHeight)


    def resize_window(self, pbfWidth, pbfHeight):
        #this doesn't work well with the scrollbars. I don't know if I just need to call some random function or if it's a gtk bug.
        #http://www.gtkforums.com/about6831.html
        winWidth = pbfWidth if pbfWidth < self.sWidth else self.sWidth
        winHeight = pbfHeight if pbfHeight < self.sHeight else self.sHeight

        self.win.resize(winWidth, winHeight)


    def update_title(self):
        self.win.set_title("pim %d/%d %d%% %s%s" % (self.index, len(self.paths),
            self.zoom_percent * 100, self.paths[self.index], ' [slideshow]' if self.slideshow else ''))


    def zoom_delta(self, delta):
        self.zoom_percent = self.zoom_percent + delta
        self.update_image()


    def zoom_to(self, percent):
        self.zoom_percent = percent if percent else self.get_fullscreen_zoom_percent()
        self.update_image()


    def move_index(self, delta):
        self.index = (self.index + delta) % len(self.paths)

        #reshuffle on wrap-around
        if self.random and self.index is 0 and delta > 0:
            shuffle(self.paths)

        path = self.paths[self.index]
        self.pixbufOriginal = GdkPixbuf.Pixbuf.new_from_file(path)
        if not self.zoom_lock:
            if self.fullscreen:
                self.zoom_percent = self.get_fullscreen_zoom_percent()
            else:
                self.zoom_percent = 1
        self.update_image()

        self.scroll(Gtk.ScrollType.START, False)
        self.scroll(Gtk.ScrollType.START, True)

        return True #for the slideshow


    def parse_args(self):
        usage = "usage: %prog [options] path1 [path2 path3 ...]"
        parser = OptionParser(usage=usage)
        parser.add_option("-r", "--random", action="store_true", dest="random", help="randomize filelist", default=self.random)
        parser.add_option("-R", "--no-random", action="store_false",   dest="random", help="don't randomize")
        (options, args) = parser.parse_args()
        self.random = options.random

        if len(args) is 0:
            parser.error('need at least one path!')

        if not self.populate(args):
            parser.error('no loadable images detected')


    def populate(self, args):
        ''' Generate a list of paths from the given arguments '''

        #get supported mimetypes
        types = []
        for pixbuf_format in GdkPixbuf.Pixbuf.get_formats():
            types.extend(pixbuf_format.get_mime_types())

        #if only one arg passed, do special stuff
        single = None
        if len(args) is 1:
            arg = args[0]
            if os.path.isfile(arg):
                #use parent directory
                single = args[0]
                abspath = os.path.abspath(single)
                directory = os.path.dirname(abspath)
                args = (directory,)
            elif os.path.isdir(arg) and self.remember_position:
                try:
                    f = open('pim-position')
                    single = f.read()
                except IOError as e:
                    print(e)

        #add everything
        self.paths = []
        for arg in args:
            path = os.path.abspath(arg)
            if os.path.isfile(path):
                self.paths.append(path)
            elif os.path.isdir(path):
                paths = [os.path.join(path, x) for x in os.listdir(path)]
                paths.sort()
                self.paths.extend(paths)
            else:
                print("%s is not a valid path!" % arg)

        #remove unsupported files
        self.paths = [path for path in self.paths if mimetypes.guess_type(path)[0] in types]

        #shuffle
        if self.random:
            shuffle(self.paths)

        #complete special stuff for single arg
        if single and single in self.paths:
            self.index = self.paths.index(single)
        else:
            self.index = 0

        return len(self.paths)


    def handle_key_press(self, widget, event):
        #ignore everything but shift, control, and alt modifiers
        state = event.get_state() & (Gdk.ModifierType.SHIFT_MASK | Gdk.ModifierType.CONTROL_MASK | Gdk.ModifierType.MOD1_MASK)
        keyval = event.keyval
        for bind in self.binds:
            if keyval == bind[1] and state == bind[0]:
                funk = bind[2]
                args = bind[3:]
                funk(*args)
                return
        print(event)


    def main(self):
        self.parse_args()

        screen = Gdk.Screen()
        self.sWidth = screen.width()
        self.sHeight = screen.height()
        self.sRatio = self.sWidth / self.sHeight

        self.win = Gtk.Window()
        self.win.connect('destroy', Gtk.main_quit)
        self.win.connect("key_press_event", self.handle_key_press)

        self.scrolled_win = Gtk.ScrolledWindow()
        self.win.add(self.scrolled_win)

        viewport = Gtk.Viewport()
        viewport.modify_bg(Gtk.StateType.NORMAL, Gdk.color_parse('#FFFFFF'))
        viewport.set_shadow_type(Gtk.ShadowType.NONE)
        self.scrolled_win.add(viewport)

        self.image = Gtk.Image()
        viewport.add(self.image)

        self.move_index(0)
        self.win.show_all()
        if self.fullscreen:
            self.win.fullscreen()
        Gtk.main()


if __name__ == '__main__':

    Pim().main()
